# 自分AI簡易版Lv1 開発記録
## 試行錯誤と失敗の記録

**作成日**: 2025年1月27日  
**目的**: AI開発における試行錯誤の記録と、同じ失敗を避けるための教訓集  
**対象**: 自分AI簡易版Lv1の自動ファイル更新機能開発

---

## 📋 プロジェクト概要

### 初期の課題
- **問題**: Geminiがファイルの内容を更新できない
- **要望**: 「Gemの操作だけで完結する仕組み」の実現
- **制約**: Googleドライブ前提での運用

### 開発の流れ
1. 問題の理解と分析
2. 複数の解決策の検討
3. 実装の試行錯誤
4. 制約の再発見
5. 現実的な解決策への回帰

---

## 🔍 試行錯誤の詳細記録

### フェーズ1: 問題の理解と分析

#### 初期の理解
```
ユーザー: 「Geminiがファイルの内容を更新できないと言っています。
どうすればGemのチャット状で自動で既存ファイルの編集ができますか？
GASかPythonファイル入れれば編集できる？」
```

#### 私の最初の分析
- **理解**: Gemini Gemsは読み取り専用で、Google Driveのファイルを直接編集できない
- **提案**: GAS（Google Apps Script）による自動化システム
- **想定**: GeminiからGASを呼び出してファイルを自動更新

#### 最初の提案内容
1. **GAS（Google Apps Script）による自動化**
2. **Pythonスクリプトによる自動化**
3. **実装手順の詳細説明**

### フェーズ2: GAS実装の詳細設計

#### GASコードの作成
```javascript
// Google Apps Script: 自分AI自動更新システム
function updateJibunAIFile(fileName, content, section) {
  const folderId = 'YOUR_GOOGLE_DRIVE_FOLDER_ID';
  const folder = DriveApp.getFolderById(folderId);
  const files = folder.getFilesByName(fileName);
  
  if (files.hasNext()) {
    const file = files.next();
    const currentContent = file.getBlob().getDataAsString();
    const updatedContent = addContent(currentContent, content, section);
    file.setContent(updatedContent);
    return 'ファイルが正常に更新されました';
  }
  return 'ファイルが見つかりません';
}
```

#### システムプロンプトの修正
- GAS連携機能を追加
- 自動更新のフローを明記
- 利用可能な関数を定義

#### Mode1, Mode2の修正
- GAS自動更新の実行フローを追加
- 手動更新から自動更新に変更
- 更新完了の報告機能を追加

### フェーズ3: フォルダ構成の最適化

#### 問題の認識
```
ユーザー: 「Gemはドライブのフォルダごと添付できなからフォルダは1つにして」
```

#### 私の誤解
- **誤解**: 「フォルダを1つにする」= 統合ファイルを作成する
- **実際**: サブフォルダを削除してフラット構成にする

#### 誤った実装
- 統合ファイル（`自分AI_統合ファイル.md`）を作成
- すべての内容を1つのファイルにまとめる

#### 正しい理解と修正
- サブフォルダ（`knowledge/`, `modes/`）を削除
- すべてのファイルをルートフォルダに移動
- 統合ファイルを削除

### フェーズ4: Gemini Extensionsの誤解

#### 私の誤った提案
```
「Gemini ExtensionsでGASを登録
- Gemini Extensionsの設定画面を開く
- 「カスタム関数」を追加
- 関数名：update_jibun_ai_file
- URL：上記で取得したWebアプリURL」
```

#### ユーザーの指摘
```
ユーザー: 「なにこれ説明して。GeminiExtensionなんてある＞」
```

#### 現実の確認
- **Gemini Extensions**という機能は存在しない
- カスタム関数を追加する機能はない
- 外部APIを直接呼び出す機能はない

### フェーズ5: Googleドキュメント変換の誤解

#### 私の提案
```
「Googleドキュメントに変換すれば、Geminiが直接編集可能になります！」
```

#### ユーザーの指摘
```
ユーザー: 「は？GemからGoogleドキュメントの内容読み込めないだろ？」
```

#### 現実の確認
- GeminiはGoogleドキュメントの内容を直接読み込めない
- 外部ファイルを直接編集できない
- カスタム関数を追加できない

### フェーズ6: 現実的な制約の理解

#### 最終的な理解
- **Geminiの制限**:
  - 読み取り専用
  - 外部ファイルを直接編集できない
  - カスタム関数を追加できない
  - Googleドキュメントの内容を直接読み込めない

- **実際に可能なこと**:
  - PDFファイルの内容を読み込める
  - テキストファイルの内容を読み込める
  - 画像ファイルの内容を読み込める

#### 現実的な解決策
- 手動更新（現在の方法）
- PDF変換（更新が面倒）
- テキストファイル変換（フォーマット失われる）

---

## 🚨 失敗の分析

### 失敗1: 存在しない機能の提案

#### 失敗内容
- **Gemini Extensions**という存在しない機能を提案
- カスタム関数を追加する機能を想定
- 外部APIを直接呼び出す機能を想定

#### 失敗の原因
- 最新の情報を確認せずに推測で回答
- ユーザーの要望に応えようとして、実現不可能な機能を提案
- 技術的な制約を十分に理解していない

#### 教訓
- 提案する機能は必ず存在確認を行う
- 実現可能性を事前に検証する
- 推測ではなく、確実な情報のみを提供する

### 失敗2: 要件の誤解

#### 失敗内容
- 「フォルダを1つにする」を「統合ファイルを作成する」と誤解
- 実際の要望は「サブフォルダを削除してフラット構成にする」

#### 失敗の原因
- ユーザーの要望を十分に理解せずに推測
- 確認せずに実装を開始
- 文脈を正しく読み取れていない

#### 教訓
- 要望は必ず確認してから実装する
- 曖昧な表現は明確化を求める
- 推測ではなく、確認を優先する

### 失敗3: 技術的制約の無視

#### 失敗内容
- Geminiの制約を無視して自動化を提案
- 実現不可能な機能を詳細に設計
- 現実的な制約を考慮しない

#### 失敗の原因
- 技術的な制約を十分に理解していない
- 理想的な解決策を追求しすぎ
- 現実的な制約を軽視

#### 教訓
- 技術的な制約を最初に確認する
- 現実的な制約を考慮した解決策を提案する
- 理想と現実のバランスを取る

### 失敗4: 段階的な検証の不足

#### 失敗内容
- 各段階で検証せずに次の段階に進む
- 前提条件を確認せずに実装
- 失敗の早期発見ができない

#### 失敗の原因
- 段階的な検証プロセスを設けていない
- 前提条件の確認を怠る
- 失敗の早期発見メカニズムがない

#### 教訓
- 段階的な検証プロセスを設ける
- 各段階で前提条件を確認する
- 失敗の早期発見メカニズムを構築する

---

## 📚 学んだ教訓

### 1. 技術的制約の確認
- **教訓**: 提案する機能は必ず存在確認を行う
- **実践**: 最新の情報を確認してから提案する
- **チェックリスト**:
  - [ ] 機能の存在確認
  - [ ] 技術的な制約の確認
  - [ ] 実現可能性の検証

### 2. 要件の明確化
- **教訓**: 要望は必ず確認してから実装する
- **実践**: 曖昧な表現は明確化を求める
- **チェックリスト**:
  - [ ] 要望の詳細確認
  - [ ] 曖昧な表現の明確化
  - [ ] 実装前の最終確認

### 3. 段階的な検証
- **教訓**: 段階的な検証プロセスを設ける
- **実践**: 各段階で前提条件を確認する
- **チェックリスト**:
  - [ ] 前提条件の確認
  - [ ] 段階的な検証
  - [ ] 失敗の早期発見

### 4. 現実的な解決策
- **教訓**: 現実的な制約を考慮した解決策を提案する
- **実践**: 理想と現実のバランスを取る
- **チェックリスト**:
  - [ ] 制約の考慮
  - [ ] 現実的な解決策
  - [ ] 理想と現実のバランス

---

## 🔄 開発プロセスの改善案

### 改善された開発プロセス

#### ステップ1: 問題の理解
1. **問題の詳細確認**
   - 現在の状況を正確に把握
   - 制約条件を明確化
   - 目標を具体化

2. **技術的制約の確認**
   - 使用技術の制約を調査
   - 実現可能性を検証
   - 代替案を検討

#### ステップ2: 解決策の検討
1. **複数の解決策の検討**
   - 理想的な解決策
   - 現実的な解決策
   - 段階的な解決策

2. **解決策の評価**
   - 実現可能性
   - コスト・工数
   - リスク

#### ステップ3: 実装と検証
1. **段階的な実装**
   - 最小限の実装から開始
   - 各段階で検証
   - 問題の早期発見

2. **継続的な検証**
   - 前提条件の確認
   - 動作確認
   - ユーザーフィードバック

#### ステップ4: 改善と最適化
1. **問題の分析**
   - 失敗の原因分析
   - 改善点の特定
   - 教訓の抽出

2. **プロセスの改善**
   - 開発プロセスの改善
   - チェックリストの更新
   - ベストプラクティスの確立

---

## 📋 チェックリスト

### 開発開始前のチェックリスト
- [ ] 問題の詳細確認
- [ ] 制約条件の明確化
- [ ] 技術的制約の確認
- [ ] 実現可能性の検証
- [ ] 目標の具体化

### 解決策提案前のチェックリスト
- [ ] 機能の存在確認
- [ ] 技術的な制約の確認
- [ ] 実現可能性の検証
- [ ] 代替案の検討
- [ ] リスクの評価

### 実装前のチェックリスト
- [ ] 要望の詳細確認
- [ ] 曖昧な表現の明確化
- [ ] 前提条件の確認
- [ ] 段階的な実装計画
- [ ] 検証方法の決定

### 実装中のチェックリスト
- [ ] 段階的な検証
- [ ] 前提条件の確認
- [ ] 動作確認
- [ ] 問題の早期発見
- [ ] ユーザーフィードバック

### 実装後のチェックリスト
- [ ] 問題の分析
- [ ] 失敗の原因分析
- [ ] 改善点の特定
- [ ] 教訓の抽出
- [ ] プロセスの改善

---

## 🎯 最終的な結論

### 現実的な解決策
- **手動更新**: 現在の方法が最も確実で実用的
- **改善案**: 手動更新を簡単にする仕組みの提供
- **将来性**: 技術の進歩に合わせて段階的に改善

### 開発の教訓
1. **技術的制約の確認**を最初に行う
2. **要件の明確化**を必ず実施する
3. **段階的な検証**プロセスを設ける
4. **現実的な解決策**を優先する
5. **失敗から学ぶ**姿勢を維持する

### 今後の方針
- 現実的な制約を考慮した開発
- 段階的な改善と最適化
- 継続的な学習と改善
- ユーザーフィードバックの重視

---

## 📝 記録の活用方法

### 開発チーム向け
- 同じ失敗を避けるための参考資料
- 開発プロセスの改善材料
- ベストプラクティスの確立

### 個人向け
- 学習記録としての活用
- スキルアップの参考資料
- 問題解決能力の向上

### 組織向け
- ナレッジベースの構築
- 開発プロセスの標準化
- 品質向上の取り組み

---

## フェーズ7: Google Keep連携の実現（2025年10月25日）

### 背景と目標
- **目標**: 「Gemの操作だけで完結する仕組み」の実現
- **前回の失敗**: 存在しない機能（Gemini Extensions等）の提案
- **今回のアプローチ**: 過去の教訓を活かし、技術的制約の確認を最優先

---

### 開発の流れ

#### ステップ1: ユーザーからの提案
```
ユーザー提案の流れ:
0. ユーザーは初回使用前にGoogleKeepで各knowledgeファイル名と同じメモを作成
1. ユーザーがGemのチャットにknowledgeのもととなる内容を入力
2. GemがGoogleKeepのメモを作成（knowledgeファイルとして機能）
3. ユーザーが更新を依頼した場合、既存メモを読み取り→新規データ追加→古いKeepを削除
4. mode3-5実行時にknowledgeとなるgoogleKeepを参照してアウトプット作成
```

#### ステップ2: 技術的制約の確認（慎重なアプローチ）

**私の対応**:
- 過去の失敗（Gemini Extensions）を繰り返さないため、Web検索で公式情報を確認
- 検索結果：「Geminiは作成・読み取り・追加は可能、**削除は不可能**」

**最初の方針提案**:
削除不可を前提に3つの代替案を提案：
- **方向性A-1**: 追記専用方式（削除不要、重複を許容）
- **方向性A-2**: 世代管理方式（v1, v2...で履歴管理）
- **方向性B**: 現状方式の改善（Markdownファイル維持）
- **方向性C**: ハイブリッド方式（段階的にKeep導入）

推奨方針：**方向性C（ハイブリッド）**
- Lv.1は現状方式で確実性確保
- Lv.2以降でKeep活用を実験的に導入

#### ステップ3: ユーザーからの重要な訂正

```
ユーザー: 「いえ、GeminiでKeepメモを削除できます。実験済みです。」
```

**この指摘の重要性**:
- Web検索の情報より実験結果が優先
- 削除可能という前提で設計が大きく変わる

#### ステップ4: 方針の即時再構築

**削除可能前提での新方針**:
- Google Keep中心設計に全面変更
- Markdownファイルは配布用テンプレートのみ
- 実運用は完全にKeepで完結

**確認した技術詳細**:
```
ユーザー確認結果:
- Gems環境でのKeep操作：メモ名を明示すれば旧版の削除可能
```

#### ステップ5: フラット構造への調整

**ユーザー**: 「フォルダは1つにしてください。Gemへのファイルアップはできても、フォルダのアップはできないため。」

**最初の提案**:
```
knowledge/  ← サブフォルダ
modes/      ← サブフォルダ
```

**修正後**:
```
フラット構造（サブフォルダなし）:
├── 00_自分AI_システムプロンプト.md
├── mode1_update.md
├── mode2_maintenance.md
├── mode3_task_management.md
├── mode4_email.md
├── mode5_content_generation.md
└── README.md
```

#### ステップ6: 不要な要素の削除

**削除した要素**:
1. **Google Keep拡張機能の有効化手順**
   - 理由: ユーザーは初回以降Keepを触らないため不要

2. **My_*.mdテンプレートファイル**
   - 理由: READMEに記入例を統合する方がシンプル
   - knowledge/ フォルダも削除

3. **「_簡易版Lv1/」などの開発者向け情報**
   - 理由: ユーザーにとって不要な情報

---

### 最終的な方針（確定）

#### ファイル構成
```
7ファイルのみのフラット構造:
├── 00_自分AI_システムプロンプト.md
├── mode1_update.md
├── mode2_maintenance.md
├── mode3_task_management.md
├── mode4_email.md
├── mode5_content_generation.md
└── README.md
```

#### データフロー
```
初期セットアップ:
1. Google Keepで3つの空メモ作成（My_Values, My_CommunicationStyle, My_Episodes）
2. Gemini Gemsに7つのファイルをアップロード

Mode1（更新）の動作:
1. 該当Keepメモ読み取り（メモ名を明示）
2. 既存内容 + 新規内容を合算
3. 同じメモ名で新規作成
4. 旧版を削除（メモ名を明示）

Mode3-5（参照）の動作:
1. 必要なKeepメモを読み取り
2. 内容を反映してアウトプット生成
```

#### ユーザー体験
- **ユーザーがKeepを触るのは初回の3メモ作成のみ**
- 以降は全てGemのチャットで完結

---

### 成功のポイント分析

#### 1. 過去の教訓を活かした慎重なアプローチ
- ✅ 技術的制約を最初に確認（Web検索実施）
- ✅ 存在しない機能を提案しない姿勢
- ✅ 複数の代替案を用意

#### 2. ユーザーの実験結果を信頼
- ✅ Web情報より実験結果を優先
- ✅ 新情報に基づき即座に方針を再構築
- ✅ 固執せず柔軟に対応

#### 3. 段階的な確認と調整
- ✅ フラット構造の要件確認
- ✅ 不要な要素の削除
- ✅ ユーザー視点での情報整理

#### 4. 要件の明確化
- ✅ 「フォルダは1つ」→「フラット構造」と正しく理解
- ✅ 「拡張機能有効化」→「不要」と削除
- ✅ 「テンプレートファイル」→「READMEに統合」

---

### 今回の開発で改善された点

#### 改善1: 技術的制約の確認プロセス
**以前**:
- 推測で機能を提案 → 失敗

**今回**:
- Web検索で公式情報確認 → 慎重な代替案提示 → ユーザーの実験結果で再構築 → 成功

#### 改善2: ユーザーフィードバックへの対応
**以前**:
- 一度提案したら固執

**今回**:
- ユーザーの「削除できる」という情報を即座に反映
- 方針を柔軟に再構築

#### 改善3: 要件の明確化
**以前**:
- 「フォルダを1つ」→「統合ファイル作成」と誤解

**今回**:
- 「フォルダは1つ」→「フラット構造」と正しく理解
- 不要な要素を段階的に削除

---

### 学んだ教訓（追加）

#### 5. Web情報と実験結果のバランス
- **教訓**: 公式情報で安全性を確認しつつ、ユーザーの実験結果を最優先
- **実践**: 慎重に調査 → 代替案用意 → 実験結果で最適化
- **チェックリスト**:
  - [ ] 公式情報の確認（安全策）
  - [ ] ユーザーの実験結果を信頼
  - [ ] 新情報に基づく即座の方針変更

#### 6. シンプルさの追求
- **教訓**: ユーザーにとって不要な情報は徹底的に削除
- **実践**: 開発者視点の情報を排除し、ユーザー視点で整理
- **チェックリスト**:
  - [ ] 開発者向け情報の削除
  - [ ] ユーザー視点での必要性確認
  - [ ] 段階的な要素の削除

---

### 今後の開発での活用

#### このフェーズから学ぶべきこと
1. **慎重さと柔軟性のバランス**
   - 過去の失敗を踏まえ慎重に調査
   - しかし新情報には柔軟に対応

2. **段階的な確認の重要性**
   - 技術的制約 → 方針提示 → ユーザー確認 → 調整 → 再確認

3. **ユーザー実験の価値**
   - 公式情報より実験結果が重要な場合がある
   - 実験結果を最優先する姿勢

4. **シンプルさの追求**
   - 不要な要素を徹底的に削除
   - ユーザー視点での情報整理

---

**この記録は、AI開発における試行錯誤の貴重な資料として、今後の開発に活用されることを期待しています。**

**作成者**: AI Assistant
**作成日**: 2025年1月27日
**最終更新**: 2025年10月25日（フェーズ7追加）
**バージョン**: 1.1
